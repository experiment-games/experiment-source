#include "cbase.h"
#include "gmod_luabase.h"

// memdbgon must be the last include file in a .cpp file!!!
#include "tier0/memdbgon.h"

lua_StateWithCompat *CreateLuaStateWithCompat( lua_State *L )
{
    lua_StateWithCompat *ext = ( lua_StateWithCompat * )malloc( sizeof( lua_StateWithCompat ) );
    ext->luabase = &CLuaBase::GetInstance( L );
    ext->L = L;

    return ext;
}

lua_StateWithCompat *ToLuaStateWithCompat( lua_State *L )
{
    return ( lua_StateWithCompat * )L;
}

CLuaBase &CLuaBase::GetInstance( lua_State *L )
{
    static CLuaBase instance;

    instance.L = L;

    return instance;
}

void CLuaBase::SetState( lua_StateWithCompat *LCompat )
{
    this->L = LCompat->L;
}

/// <summary>
/// Wraps the Lua function so the compat state can be passed to it
/// </summary>
/// <param name="L"></param>
/// <returns></returns>
int CompatFunctionWrapper( lua_State *L )
{
    if ( !g_bLuaInitialized )
    {
        // Prevent issues where this function is called during/after lua_close
        return 0;
    }

    GarrysMod::Lua::CFunc originalFunc = *static_cast< GarrysMod::Lua::CFunc * >( lua_touserdata( L, lua_upvalueindex( 1 ) ) );
    lua_StateWithCompat *compatState = CreateLuaStateWithCompat( L );

    int result = originalFunc( compatState );

    free( compatState );

    return result;
}

void CLuaBase::PushCFunction( GarrysMod::Lua::CFunc val )
{
    // Store the function pointer in a userdata
    GarrysMod::Lua::CFunc *userData = static_cast< GarrysMod::Lua::CFunc * >( lua_newuserdata( L, sizeof( GarrysMod::Lua::CFunc ) ) );
    *userData = val;

    // Push the wrapper function with the userdata as an upvalue
    lua_pushcclosure( L, CompatFunctionWrapper, 1 );
}

int CLuaBase::ReferenceCreate()
{
    return luaL_ref( L, LUA_REGISTRYINDEX );
}

void CLuaBase::ReferenceFree( int i )
{
    luaL_unref( L, LUA_REGISTRYINDEX, i );
}

void CLuaBase::ReferencePush( int i )
{
    lua_rawgeti( L, LUA_REGISTRYINDEX, i );
}

void CLuaBase::PushCClosure( GarrysMod::Lua::CFunc val, int iVars )
{
    Assert( 0 );  // This isn't implemented yet, this is generated by copilot and wont work
    lua_pushcclosure( L, reinterpret_cast< lua_CFunction >( val ), iVars );
}

int CLuaBase::CreateMetaTable( const char *strName )
{
    if ( luaL_newmetatable( L, strName ) )
    {
        m_mapMetaTableNameToID.AddToTail( strName );
    }
    else
    {
        // TODO: This else is reached when running `lua_run require("mysqloo")` twice,
        //       causing it to run this CreateMetaTable method twice.
        return m_mapMetaTableNameToID.Find( strName );
    }

    return m_mapMetaTableNameToID.Count() - 1;
}

bool CLuaBase::PushMetaTable( int iType )
{
    if ( iType < 0 || iType >= m_mapMetaTableNameToID.Count() )
        return false;

    luaL_getmetatable( L, m_mapMetaTableNameToID[iType] );
    return true;
}

void CLuaBase::PushUserType( void *data, int iType )
{
    auto *ud = static_cast< UserData * >( NewUserdata( sizeof( UserData ) ) );
    ud->data = data;
    ud->type = iType;

    // Set the metatable
    if ( PushMetaTable( iType ) )
        SetMetaTable( -2 );
}

void CLuaBase::SetUserType( int iStackPos, void *data )
{
    auto *ud = static_cast< GarrysMod::Lua::UserData * >( lua_touserdata( L, iStackPos ) );
    ud->data = data;
}
